import { EventEmitter } from "events";/** * Creates a new PatternEmitter, which composites EventEmitter. In addition to * EventEmitter's prototype, it allows listeners to register to events matching * a RegExp. * * @constructor * @extends EventEmitter * * @property {*} event The type of the last emitted event */export class PatternEmitter {    public event: string;    private _emitter: EventEmitter;    private _emit: Function;    private _addListener: Function;    private _removeListener: Function;    private _removeAllListeners: Function;    private _regexesCount: number = 0;    private _events: Record<string, any> = {};    private _patternEvents: Record<string, any> = {};    private _regexes: Map<string, RegExp>;    constructor() {        this._emitter = new EventEmitter();        this.event = '';        this._regexesCount = 0;        this._events = this._events || {};        this._patternEvents = this._patternEvents || {};        this._regexes = new Map<string, RegExp>();        this._emit = this._emitter.emit.bind(this);        this._addListener = this._emitter.addListener.bind(this);        this._removeListener = this._emitter.removeListener.bind(this);        this._removeAllListeners = this._emitter.removeAllListeners.bind(this);        this.on = this._emitter.addListener.bind(this);        this.off = this._emitter.removeListener.bind(this);    }    /**     * Emits an event to all listeners for the specified type. In addition, if type     * is a string, emits the event to all listeners whose patterns match. Returns     * true if any listeners existed, false otherwise.     *     * @param {*}    type   The type of event to emit     * @param {...*} [args] Arguments to apply when invoking the listeners     *     * @returns {PatternEmitter} This instance     * @throws  {Error}          If an error occurs and no error listener exists     */    public emit(type): void {        let listeners, result, error;        // Optimize for the case where no pattern listeners exit        if (!this._regexesCount) {            // this._emitter.emit.apply(this, arguments);            return this._emit.apply(this, arguments);        }        this.event = type;        listeners = this._events[type];        this._events[type] = this._getMatching(type);        try {            result = this._emit.apply(this, arguments);        } catch (err) {            error = err;        }        this._events[type] = listeners;        if (error) throw error;        return result;    }    /**     * Given a RegExp event type, stores the regular expression and registers the     * listener to any events matching the pattern. Otherwise, it behaves exactly     * as EventEmitter. As with EventEmitter.prototype.addListener, it emits a     * 'newListener' event on success. Returns an instance of itself.     *     * @param {*}        type     The event type to match, including a RegExp to     *                            match using a pattern     * @param {function} listener The listener to invoke     *     * @returns {PatternEmitter} This instance     * @throws  {TypeError}      If listener is not a function     */    public addListener(type: RegExp | string | Symbol, listener) {        // ** the standart        if (!(type instanceof RegExp)) {            return this._emitter.addListener(type, listener);        }        const regex: RegExp = type;        // string representation        const pattern: string = String(type);        this.event = 'newListener';        this._regexesCount++;        this._apply(this._addListener, pattern, [pattern, listener]);        if (!this._regexes[pattern]) {            this._regexes[pattern] = regex;        }        return this;    }    /**     * Removes the listener from the specified event type. If given an instance of     * RegExp, it matches any RegExp object with the same expression. Emits a     * 'removeListener' event on success. Returns an instance of itself.     *     * @param {*}        type     The event type, including a RegExp, to remove     * @param {function} listener The listener to remove     *     * @returns {PatternEmitter} This instance     * @throws  {TypeError}      If listener is not a function     */    public removeListener(type, listener) {        if (!(type instanceof RegExp)) {            return this._removeListener(type, listener);        }        const regexp: RegExp = type;        const pattern: string = String(type);        this.event = 'removeListener';        this._regexesCount--;        this._apply(this.removeListener, pattern, [pattern, listener]);        if (!this._patternEvents[pattern] || !this._patternEvents[pattern].length) {            delete this._patternEvents[pattern];        }        if (!this._patternEvents[pattern] && this._regexes[pattern]) {            delete this._regexes[pattern];        }        return this;    }    /**     * Removes all listeners for the specified event type. If given an instance of     * RegExp, it matches the RegExp object with the same expression. Emits a     * 'removeListener' event for each removed listener. Returns an instance of     * itself.     *     * @param {*} type The event type, including a RegExp, to remove     *     * @returns {PatternEmitter} This instance     */    public removeAllListeners(type): void {        if (!(type instanceof RegExp)) {            return this._emitter.removeAllListeners(type);        }        const pattern: string = String(type);        this.event = 'removeListener';        this._apply(this.removeAllListeners, pattern, [pattern]);        delete this._patternEvents[pattern];        if (this._regexes[pattern]) {            delete this._regexes[pattern];        }        return this;    }    /**     * A helper function to invoke an EventEmitter action in the context of     * pattern listeners. This allows us to re-use EventEmitter's logic and API.     *     * @param {function}       fn      The function to invoke     * @param {pattern}        pattern The string pattern to which this applies     * @param {*[]}            args    An array of arguments to apply to fn     *     * @returns {*} The function's return value     */    private _apply(fn, pattern, args) {        // Swap patternEvents and events before running, allowing us to piggyback        // off EventEmitter        let typeListeners, error, result;        typeListeners = this._events[pattern];        this._events[pattern] = this._patternEvents[pattern];        try {            result = fn.apply(this, args);        } catch (err) {            error = err;        }        this._patternEvents[pattern] = this._events[pattern];        this._events[pattern] = typeListeners;        if (error) throw error;        return result;    }    /**     * Returns an array of pattern listeners for the specified RegExp.     *     * @param {RegExp} pattern A RegExp     *     * @returns {function[]} An array of listeners     * @throws  {TypeError}  If pattern is not a RegExp     */    private patternListeners(pattern) {        if (!(pattern instanceof RegExp)) {            throw TypeError('pattern must be an instance of RegExp');        }        return PatternEmitter._apply(this, this.listeners, pattern, [pattern]);    }    /**     * Returns an array of listeners for the supplied event type, and whose     * patterns match the event if given a string.     *     * @param {*} type The type of event     *     * @returns {function[]} An array of listeners     */    private matchingListeners(type) {        let matching = this._getMatching(type);        if (!matching) {            matching = [];        } else if (!(matching instanceof Array)) {            matching = [matching];        }        return matching;    }    /**     * Returns the number of listeners for a given event. An alias for     * EventEmitter.listenerCount.     *     * @see EventEmitter.listenerCount     *     * @param {PatternEmitter} emitter The emitter for which to count listeners     * @param {*}              type    The event type     *     * @returns {int} The number of listeners     */    public listenerCount(emitter, type) {        return EventEmitter.listenerCount(emitter, type);    }    /**     * Returns the number of listeners registered to the emitter for the specified     * pattern.     *     * @param {PatternEmitter} emitter The emitter for which to count listeners     * @param {RegExp}         pattern A RegExp     *     * @returns {int}       The number of listeners     * @throws  {TypeError} If pattern is not a string     */    patternListenerCount(emitter, pattern) {        if (!(pattern instanceof RegExp)) {            throw TypeError('pattern must be an instance of RegExp');        }        return this._apply(emitter, EventEmitter.listenerCount, pattern,            [emitter, pattern]);    }    /**     * Returns the number of listeners and pattern listeners registered to the     * emitter for the event type or a matching pattern.     *     * @param {PatternEmitter} emitter The emitter for which to count listeners     * @param {*}              type    The event type     *     * @returns {int} The number of listeners     */    matchingListenerCount(emitter, type) {        return emitter.matchingListeners(type).length;    }    /**     * Returns all listeners for the given type, and if type is a string, matching     * pattern listeners.     *     * @param {*} type The event type     *     * @returns {function|function[]} All relevant listeners     */    _getMatching(type: RegExp | string | Symbol) {        const matching, listeners;        // Get any regular listeners        matching = this._events[type];        if (typeof type !== 'string') {            return matching;        }        // Retrieve all pattern listeners        for (const pattern in this._regexes) {            const regex = this._regexes[pattern];            if (!regex || !(regex instanceof RegExp)) {                continue;            }            if (!regex.test(type)) continue;            if (!matching) {                matching = this._patternEvents[pattern];            } else {                listeners = this._patternEvents[pattern];                if (!(listeners instanceof Array)) {                    listeners = [listeners];                }                if (!(matching instanceof Array)) {                    matching = [matching];                }                matching = matching.concat(listeners);            }        }        return matching;    }}