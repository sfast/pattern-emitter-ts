# Cursor Rules for @sfast/pattern-emitter-ts

## Project Overview
This is a TypeScript library that extends Node.js EventEmitter with RegExp pattern matching support.
- **Language**: TypeScript 5.7.2
- **Test Framework**: Jest 29.7.0
- **Code Style**: Google TypeScript Style (gts)
- **Target**: Production library with 100% test coverage

## Code Style & Standards

### TypeScript
- Use strict TypeScript mode (already configured in tsconfig.json)
- Prefer explicit types over `any` (use `any` only when necessary for flexibility)
- Use ES2020 features (target is ES2020)
- Follow Google TypeScript Style guidelines
- Use JSDoc comments for all public APIs

### Naming Conventions
- Classes: PascalCase (e.g., `PatternEmitter`)
- Interfaces: PascalCase with `I` prefix (e.g., `IPatternEmitter`)
- Types: PascalCase (e.g., `EventPattern`, `PatternListener`)
- Private fields: camelCase with `_` prefix (e.g., `_listeners`)
- Public methods: camelCase (e.g., `addListener`)

### File Organization
```
src/
  index.ts           # Main export
  patternEmitter.ts  # Core implementation
  interface.ts       # Interface definitions
  types.ts           # Type definitions
  utils/             # Utility functions
test/
  patternEmitter.test.ts  # All tests in one file
```

## Development Guidelines

### Testing Requirements
- **CRITICAL**: Maintain 100% code coverage
- Write tests for ALL new features before implementation
- Test both string and RegExp event patterns
- Test edge cases (empty listeners, removeAll, once, etc.)
- Run `npm test` before committing

### Code Quality Checks
1. `npm run build` - Must compile without errors
2. `npm test` - All tests must pass with 100% coverage
3. `npm run lint` - No linting errors
4. `npm run fix` - Auto-fix formatting issues

### When Making Changes

#### Adding New Features
1. Update `src/interface.ts` if adding public API
2. Update `src/types.ts` if adding new types
3. Add JSDoc comments with `@param`, `@return`, `@example`
4. Write tests first (TDD approach)
5. Update README.md with usage examples
6. Run `npm run docs` to regenerate documentation

#### Modifying Core Logic
- The `PatternEmitter` class wraps listeners with `wrapListener()` to maintain order
- Listener order is preserved using a global index (`_globalListenerIndex`)
- String events use native EventEmitter, RegExp events use custom `_listeners` Map
- Never break backward compatibility with EventEmitter API

#### Bug Fixes
1. Write a failing test that reproduces the bug
2. Fix the bug
3. Verify test passes
4. Check no other tests broke

### Architecture Principles

1. **Backward Compatibility**: Must remain 100% compatible with Node.js EventEmitter
2. **Type Safety**: Leverage TypeScript for compile-time safety
3. **Performance**: Optimize for event emission (hot path)
4. **Simplicity**: Keep API surface small and intuitive

### Key Implementation Details

- `_actualListeners`: Maps wrapped listeners to original listeners
- `_listeners`: Stores RegExp pattern listeners
- `_regexMap`: Stores RegExp patterns by string representation
- `wrapListener()`: Wraps each listener with an index for ordering
- `getMatchingListeners()`: Collects all listeners (string + pattern) and sorts by index

### Common Tasks

**Add a new public method:**
```typescript
// 1. Add to interface
interface IPatternEmitter {
  myNewMethod(arg: string): void;
}

// 2. Implement in PatternEmitter
/**
 * Description of what it does
 * @param {string} arg - Description of parameter
 * @return {void}
 */
public myNewMethod(arg: string): void {
  // implementation
}

// 3. Write tests
it('myNewMethod does X', () => {
  emitter.myNewMethod('test');
  expect(...).to.equal(...);
});
```

**Add a new type:**
```typescript
// In src/types.ts
export type MyNewType = string | number;
```

### Testing Patterns

```typescript
// Use Chai assertions
expect(value).to.equal(expected);
expect(value).to.be.instanceOf(Class);
expect(array).to.eql([...]);

// Test listeners are called
let called = false;
emitter.on('event', () => { called = true; });
emitter.emit('event');
expect(called).to.equal(true);

// Test RegExp patterns
emitter.on(/^prefix/, handler);
emitter.emit('prefix:something'); // Should match
```

### Documentation

- Use JSDoc with `@param`, `@return`, `@example` tags
- Keep README.md examples up to date
- Generate docs with `npm run docs` before releasing

### Publishing Checklist

1. Run all tests: `npm test`
2. Run linter: `npm run lint`
3. Update version in `package.json`
4. Update `CHANGELOG.md`
5. Build: `npm run build`
6. Verify package contents: `npm pack --dry-run`
7. Generate docs: `npm run docs`
8. Commit and tag: `git tag v0.x.x`

## Don't Do

❌ Don't use `any` unless absolutely necessary  
❌ Don't break EventEmitter compatibility  
❌ Don't reduce test coverage below 100%  
❌ Don't commit without running tests  
❌ Don't modify `dist/` directly (it's generated)  
❌ Don't add dependencies (keep it zero-dependency)  
❌ Don't use console.log (use proper logging if needed)  
❌ Don't modify `.pnp.*` or `.yarn/` files  

## Do

✅ Write tests first (TDD)  
✅ Use meaningful variable names  
✅ Add JSDoc comments for public APIs  
✅ Keep backward compatibility  
✅ Run `npm run fix` before committing  
✅ Update README for new features  
✅ Maintain 100% test coverage  
✅ Follow Google TypeScript Style  

## Useful Commands

```bash
npm run build       # Compile TypeScript
npm test            # Run tests with coverage
npm run lint        # Check code style
npm run fix         # Auto-fix style issues
npm run check       # Run gts check
npm run docs        # Generate TypeDoc
npm pack --dry-run  # Preview npm package contents
```

## Questions to Ask Before Changes

1. Does this maintain EventEmitter compatibility?
2. Are there tests for this change?
3. Is test coverage still 100%?
4. Does this follow the existing patterns in the codebase?
5. Is the public API documented with JSDoc?
6. Does this introduce any breaking changes?

## When in Doubt

- Follow existing code patterns in `src/patternEmitter.ts`
- Check how EventEmitter does it
- Prioritize simplicity over cleverness
- Ask for clarification rather than assume

